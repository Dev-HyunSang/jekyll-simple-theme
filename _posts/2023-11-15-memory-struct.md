---
layout: post
type: post
title: 우리 컴퓨터의 메모리는 어떻게 동작할까?
summary: 우리 주변에서 자주 찾아볼 수 있는 컴퓨터의 메모리는 어떻게 동작할까요?
---
안녕하세요. 박현상입니다.  
최근 알고리즘을 공부하면서 어떻게 메모리가 동작하는지 궁금하기에 따로 컴퓨터 구조론에서 메모리 구조에 대해서 이야기 해보고자 합니다. 학부에서 컴퓨터 구조론을 공부하고 있지만 개인적으로 아직 많이 공부 해야겠다고 생각이 되어서 더 자세히 공부하기 위해서 작성합니다.

**[메모리의 기본 구조와 동작](https://goodmilktea.tistory.com/30)를 보고 작성하였습니다.**

## 메모리의 기본적인 개념
메모리는 CPU와 같은 반도체 하드웨어로서 일종의 데이터를 저장하는 저장장치 역할을 수행합니다.  
데이터를 읽고 쓰는 속도가 매우 빠르고 CPU가 직접 접근이 가능합니다. 컴퓨터의 전원이 꺼지면 저장된 데이터가 모두 사라지는 특성(휘발성)을 가지고 있기 때문에 단순히 주소로서만 접근하는 저장공간입니다.  
프로그램이 실행되기 위해서는 반드시 그 내용이 메모리에 저장되어야 하고 컴퓨터의 메모리 관리를 통해 하드웨어는 CPU가 주소만을 가지고 메모리에 있는 데이터를 읽거나 쓸 수 있도록 도와줘야만 합니다.  

운영 체제의 메모리 관리는 프로세스가 필요한 메모리를 어떻게 얼마만큼 할당해 줄 것인가, 프로세스가 알고 있는 주소를 통해서 실제 메모리에 어떻게 접근하도록 하는 것인가라는 **할당과 접근**이라는 두 가지 관점에서 메모리관리 기법의 핵심입니다.  

*프로세스(Procss): 컴퓨터에서 실행중인 프로그램을 의미함.

## 주소 바인딩, Address Binding
프로세스가 CPU에 의해서 실행되기 위해서는 각각의 프로세스에게 메모리가 할당돼야 합니다.  
메모리가 할당 된다는 것은 프로세스의 구성요소인 프로그램의 코드와 데이터가 실제로 메모리의 어떤 위치에 저장딜지 그 주소가 결정된다는 것을 의미합니다.  
즉 프로그램 코드 한줄한줄 데이터 영역을 이루는 변수 하나하나에 메모리 주소가 결정된다는 뜻입니다.  

이러한 과정이 주소 바인딩이며 프로세스는 이 주소 바인딩이 되어야지만 실제로 실행이 가능해집니다. 따라서 **주소 바인딩은 프로세스나 프로그램이 알고 있는 주소공간과 실제 모리 주소로의 변환 또는 매핑의 개념이라고 할 수 있습니다.**

### 프로그램의 실행 단계 별 주소 표현 방식
소스 프로그램에서 예를들면 코드들이 변수의 이름이나 함수같은 심벌(symbol) 형태로 되어 있습니다. 컴파일을 하게 되면 변수 이름이나 함수 이름들이 사라지고 그것들이 위치를 나타내는 어떤 값을 가지게 됩니다(재배치 가능 주소).  
이 주소는 실제 메모리에 바인딩 될 주소는 아닙니다. 컴파일러를 통해 그 공간이 숫자로 표현된 주소로 변환되며 연결편집기(linker)를 통해 프로세스 주소 공간의 절대 주소로 변환이 됩니다. 이 주소가 메모리 주소로 변환하는 과정을 주소 바인딩이라고 할 수 있습니다.  

컴파일 단계의 마지막인 Linking 작업을 거치게되면 최종적으로 전체 프로그램이 만들어지기 때문에 프로그램 하나의 전체 주소를 갖게 됩니다.  
즉 0번지부터 4G번지까지 주소공간을 가지게 된다고 할 수 있습니다. 하지만 이 주소 또한 실제 메모리의 위치를 나타내는 주소는 아닙니다. 단지 프로그램이 알고 있는 주소라고 할 수 있습니다.

요약하면 프로세스가 CPU 상에서 실제로 동작하고 실행되기 위해서는 메모리에 할당이 돼야 하고 그 말은 프로그램의 여러 요소들이 실제 메모리 주소를 할당받아야 합니다. 또한 그 전에도 이 프로그램 구성요소들은 이미 컴파일러, 링커를 통해 자기만의 주소공간에서 주소값을 가지고 있게 됩니다. **주소바인딩이라는 것은 프로그램 프로세스의 주소라는 개념과 실제 메모리 사이에서의 변환을 의미합니다**

*링커(linker) · 링크 에디터(link editor)는 컴퓨터 과학에서 컴파일러가 만들어낸 하나 이상의 목적 파일을 가져와 이를 단일 실행 프로그램으로 병합하는 프로그램.

## 주소 바인딩 시점

### 컴파일 시간, Compile Time
소스를 컴파일 하는 중에 적재될 메모리 주소를 결정할 수도 있습니다. 하지만 이렇게 컴파일 된 프로그램은 항상 같은 위치의 메모리에 적재되어야 실행될 수 있습니다. 메모리가 부족한다던가 남을때 가변적으로 메모리 할당이 될 수 있는데 이렇게 컴파일 단계에서 메모리 주소가 결정이 돼버리면 항상 그 위치에 메모리가 할당이 되어야 합니다. 다른 프로그램이 해당 주소를 포함하여 먼저 할당이 된다면 해당 프로그램의 메모리 할당이 될 수 없습니다.

### 적재 시간, Load Time
Load Time에 주소 바인딩이 되는 것인데, 이것은 컴파일을 하게 되면 재배치 가능 코드가 만들어지고 실제 메모리주소가 아닌 상대 주소를 갖게 됩니다. 운영체제에 의해서 메모리에 배치될 때 그 메모리 주소는 항상 바뀔 수 있는데 그 위치에 따라서 상대 주소의 시작주소가 결정됨으로써 전체 변수들이나 기계어 코드를의 실제 메모리 위치가 결정될 수 있습니다.  
이것이 적재시간에 메모리가 바인딩 된다는 것이다. 일반적으로 주소 바인딩이 어떻게 이루어지는 것이 아니냐라고 생각할 수 있습니다.  

### 실행 시간, Execution Time
프로세스가 실행하는 도중에 메모리 위치가 바뀔 수도 있게 됩니다. 이는 가상메모리의 개념을 가지고 오면 이해할 수 있습니다. 실제 메모리 공간은 한정돼 있기 때문에 프로세스들이 메모리를 나눠 써야 합니다.  
이 작은 메모리 공간에 많은 프로그램을 실행하기 위해서 이 프로그램이 활발하게 실행하고 있을 때에는 메모리에 할당하며 스케줄링 상에서 wait 상태가 길어지게 될 때는 메모리 상에 존재하지 않고 하드디스크 상에 존재하게 하여 메모리를 관리하게 됩니다. 이를 가상메모리 기법이라며 최근 컴퓨터 시스템에서 가장 일반화가 되어 있는 메모리 관리 기법입니다.  
가상메모리 기법을 지원하기 위해서는 하드디스크에 내려갔던 프로세스가 다음번 스케줄링에 의해서 다시 메모리에 올라와야 되는데 그 위치가 고정돼 있다면 이런 교체과정이 빈번하게 반복될 때 메모리의 구조 상태가 바뀌게 됩니다. 그 바뀐 메모리 구조 상태를 활용하지 못하고 고정된 주소에만 할당하게 된다면 효율적인 메모리 관리가 될 수 없습니다.  
**가상 메모리가 운용될 때 프로그램이 하드디스크나 메모리로 교체작업이 일어날 때 임의의 위치에도 배치될 수 있도록 하기 위해서는 프로세스가 실행되는 중에도 어떤 프로세스의 코드나 데이터의 위치는 바뀔 수 있도록 해야합니다. 이것이 바로 실행시간에 메모리 주소가 바인딩 된다는 개념이라고 할 수 있다.**

*스케줄링(scheduling): 다중 프로그래밍을 가능하게 하는 운영체제의 동작 기법. 운영 체제는 프로세스들에게 CPU 등의 자원 배정을 적절히 함으로써 시스템의 성능을 개선할 수 있다.

## 논리(logical) vs 물리(physical) 주소 공간
프로세스가 실행되기 위해서는 프로세스가 알고 있는 공간의 위치정보가 실제 메모리의 주소값으로 바인딩 되어야 합니다. 프로세스의 위치정보와 실제 메모리 주소를 같은 값으로 바인딩하게 된다면 컴파일 타임 및 적재(load)타임의 바인딩은 비교적 쉽게 이룰 수 있습니다.  
하지만 이러한 방법을 사용하게 된다면 실행 시간에 바인딩을 지원할 때 문제가 발생할 수 있습니다. 프로세스가 사용하는 변수가 있고 변수가 로딩할 때 실제 어떤 주소로 바인딩 돼 있는데 이것이 실행시간에 하드디스크에 내려갔다가 다시 올라오면서 바뀌는 경우에 프로그램이 인식하는 변수의 메모리 주소차도 바뀌어야 하는 문제가 발생하게 됩니다.  
실행 중 주소의 바인딩이 새로 이루어질때마다 이 프로그램은 자기가 사용하는 변수의 메모리 주소조차도 바귀어야 하는 문제가 발생하게 됩니다. 실행 중 주소의 바인딩이 새로 이루어질 때마다 이 프로그램은 자기가 사용하는 변수의 메모리주소가 어떤 값인지 다시 알아내야하는 작업이 필요하게 됩니다. 매우 프로그램 실행이 더디거나 불편하게 되는 문제가 발생하게 됩니다. 그래서 운영체제는 프로그램이 사용하는 공간의 위치 정보를 논리주소 공간이라는 것으로 고정시켜 놓고 이것이 바인딩 되어 있는 실제 메모리의 주소 값으로 그 주소 값을 변경 시켜주는 서비스를 제공하고 있습니다.

이렇게 함으로써 런타임에 바인딩이 계속되면서 실제 그 프로세스가 저장된 실제 메뢰 위치는 계속 바뀐다 할지라도 각각의 프로세스는 그 함수 이름이나 도는 변수 이름에 해당하는 주소가 변경되지 않고 계속 같은 논리 주소 값으로 접근할 수 있는 장점을 가지게 됩니다.  
**이러한 논리 주소개념은 앞으로 메모리에 시스템을 이해하고 메모리 관리를 위해 가장 기본이 되는 개념이 됩니다.**

## 메모리 관리 장치, Memeory Management Unit

![Memeory Managment Unit Diagram](https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/MMU_principle_updated.png/325px-MMU_principle_updated.png)

운영체제가 제공하는 메모리의 관리 서비스 중에서 이 프로세스의 논리주소라는 것을 실제 메모리에 그것이 할당되어 있는 물리주소로 변환하는 작업이 가장 중요한 서비스라고 할 수 있습니다. 이러한 서비스들을 실행하기 위해 아주 빠른 특수한 하드웨어가 필요하게 되었습니다.  
컴퓨터 시스템에서 프로세스의 논리 주소를 실제 메모리의 물리 주소로 변환하는 그런 하드웨어가 있습니다. 이러한 하드웨어를 메모리 관리 장치(Memeory Managment Unit, MMU)라고 부릅니다.  

CPU나 프로세스가 이해하는 주소는 모두 논리주소입니다. 이러한 논리주소는 매번 실행할 때마다 물리 주소로 바꿔야 되기 때문에 기본적으로 이 프로세스의 어떤 데이터 텍스터가 어디에 맵필되었는지에 대한 기본 정보를 바탕으로 매우 빠른 속도로 CPU가 요구하는 주소를 실제 메모리의 주소값으로 변환시키는 작업을 수행해야 합니다, 이것이 바로 메모리 관리 장치라고 하는 MMU의 기본 원리라고 할 수 있습니다. MMU는 **동적**으로 논리 주소에 재배치 레지스터 값을 더함으로서 주소를 변환하는 역할을 합니다.  
재배치 레지스터를 사용함으로써 물리 주소는 실행 중에 얼마든지 변경될 수 있습니다.

## 함께 보면서 공부하면 좋을 자료들.
- [메모리의 주소 공간 - 물리주소와 논리주소](https://velog.io/@khs0415p/11-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84-%EB%AC%BC%EB%A6%AC%EC%A3%BC%EC%86%8C%EC%99%80-%EB%85%BC%EB%A6%AC%EC%A3%BC%EC%86%8C)
- [개발자가 알아야 하는 메모리는](https://youtu.be/CmQ_mvZpshM?si=0zsci8rEJrQ33y2w)